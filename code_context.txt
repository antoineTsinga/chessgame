// File: src/App.css
.App {
    background-color: #262522;
    color: white;
    min-height: 100vh;
}


html{
    overflow-y: scroll;
}

// File: src/App.js
import React, { useEffect, useState } from "react";

import "./App.css";

import Layout from "./components/Layout/Layout.jsx";

function App() {
  return (
    <div className="App">
      <Layout />
    </div>
  );
}

export default App;

// File: src/components/Board/Board.css
.container {
  position: relative;
  margin: auto;
  /* background-color: #666; */
  max-width: 1200px;


  
}

.board {
  /* aspect-ratio: 1; */
  aspect-ratio: 1;
  width: 100%;
  margin: auto;
  max-width: 700px;
  max-height: 700px;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  user-select: none;
  -webkit-user-select: none; /* Safari */
  -moz-user-select: none; /* Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
  /* border: 1px solid #666; */
}

.player-info{
  margin: auto;
  /* border: 1px solid black; */
}

.cell {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  background-color: white;
  /* border: 1px solid #769656; */
  cursor: pointer;
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}


.black-move-made{
  background-color:#B9CA43 !important;
}

.white-move-made{
  background-color: #F5F682 !important;
}

.reverse{
  transform: rotate(180deg)
}

.black {
  background-color: #769656;
}

.white {
  background-color: #EEEED2;
}

.cell:hover {
  border:1px solid rgb(222, 240, 85);
}

.piece {
  width: 75%;
  height: 75%;
  /* cursor: grab; */
}

/* .piece:active {
  cursor: grabbing  !important;
} */

.cell-target-piece {
  background-color: rgba(222, 240, 85) !important;
}

.possible-moves {
  position: absolute;
  width: 30%;
  height: 30%;
  background-color: rgba(12, 41, 12, 0.518) !important;
  border-radius: 50%;
}

.promotion{
  width: 30%;
  position: absolute;
  left: 35%;
  top: 50%;
  display: flex;
  background-color: rgb(110, 27, 159);
  box-shadow: 0 0 10px;
  border-radius: 5px;
  opacity: 1;
}

.promotion-background{
  position: absolute;
  left: 0;
  top: 0;
  width: 800px;
  aspect-ratio: 1;
  background-color: black;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  opacity: 0.3;
}

.promotion .piece{
  width: 25%;
  transition: ease-in-out;
}

.promotion .piece:hover{
  width: 25%;
  background-color: rgb(43, 43, 39);
  border-radius: 5px;
  
}

.win{
  display: block;
  font-size: 12em;
  text-align: center;

}




// File: src/components/Board/Board.tsx
import React, { useEffect, useState } from "react";
import { DragDropContext, Droppable } from "react-beautiful-dnd";
import Cell from "../../core/types/Cell.ts";
import Game from "../../core/config/Game.ts";
import { makeMove, showPosibleMove } from "../../core/config/utils.ts";
import { Move } from "../../core/types/Type.ts";
import "./Board.css";
import { ImagesLoader } from "../../core/config/ImagesLoader.ts";
import CellComponent from "./CellComponent.jsx";

export interface BoardProps {
  game: Game;
  setMove: React.Dispatch<React.SetStateAction<Move | null>>;
  startGame: boolean;
}

const imageLoader = ImagesLoader.instance;

const Board: React.FC<BoardProps> = ({ game, setMove, startGame }) => {
  const [current, setCurrent] = useState<Cell | null>(null);
  const [prevCell, setPrevCell] = useState<Cell | null>(null);
  const [possibleMoves, setPossibleMoves] = useState<Cell[]>([]);
  const [moveMade, setMoveMade] = useState<Cell[]>([]);
  const [promotionModale, setPromotionModale] = useState<boolean>(false);
  const [inPiece, setInPiece] = useState(null);
  const handleClick = (cell: Cell) => {
    if (promotionModale) return;
    if (game.isGameOver()) return;
    if (!game.isGameStart) return;
    if (!prevCell && game.player1.color !== cell.piece?.color) {
      return;
    }

    if (game.whoPlay.color !== game.player1.color) return;
    setCurrent(cell);

    if (prevCell && !prevCell.isEmpty) {
      if (game.isPromotion(prevCell, cell)) {
        setPromotionModale(true);
        return;
      }
      makeMove(prevCell, cell, game, setPossibleMoves, setPrevCell, setMove);
    } else {
      setCurrent(cell);
      showPosibleMove(cell, game, setPossibleMoves, setPrevCell);
    }
  };

  useEffect(() => {}, [promotionModale]);

  useEffect(() => {
    const lastMove = game.currentState;

    if (lastMove && lastMove.currentMove) {
      setMoveMade([
        game.board[lastMove.currentMove[0].row][lastMove.currentMove[0].column],
        game.board[lastMove.currentMove[1].row][lastMove.currentMove[1].column],
      ]);
    }
  }, [game, game.currentState]);

  const setPromotionCall = (cell: Cell | null, code: string) => {
    if (prevCell === null || cell === null) return;

    const move = {
      from: [prevCell.row, prevCell.column],
      to: [cell.row, cell.column],
      promotion: code,
      time: game.getTimer(game.whoPlay),
    };
    setMove(move);
    setPossibleMoves([]);
    setPrevCell(null);
    setPromotionModale(false);
  };

  const isMoveInMade = (cell: Cell) => {
    if (moveMade.length < 2) return false;

    const from = moveMade[0];
    const to = moveMade[1];

    return cell === from || cell === to;
  };

  const handleDragStart = (element, cell) => {
    setPrevCell(cell);
    setTimeout(() => {
      element.target.style.display = "none";
    }, 0);
  };
  const handleDragEnd = (element) => {
    element.target.style.display = "block";
  };

  const handleDrop = (e, cell: Cell) => {
    e.target.style.border = "unset";
    handleClick(cell);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };
  const handleDragEnter = (e, cell: Cell) => {
    e.stopPropagation();
    e.preventDefault();
    let element = !e.target.classList.contains("cell")
      ? e.target.parentElement
      : e.target;
    if (!cell.isEmpty && cell.piece?.color === prevCell?.piece?.color) return;

    if (inPiece == null) {
      element.style.border = "4px solid rgb(211, 212, 201)";
      setInPiece(element);
    } else if (element !== inPiece) {
      inPiece.style.border = "unset";
      element.style.border = "4px solid rgb(211, 212, 201)";
      setInPiece(element);
    }
  };

  function onDragEnd({ source, destination, draggableId }) {
    // dropped outside the list
    if (!destination) {
      return;
    }

    if (source.droppableId !== destination.droppableId) {
      this.props.moveTask(
        source.droppableId,
        destination.droppableId,
        draggableId
      );
    }
  }

  return (
    <div className="container">
      <div className={`board ${game.player1.color === "black" && "reverse"}`}>
        <DragDropContext onDragEnd={onDragEnd}>
          {game.board.map((row, i) =>
            row.map((cell, j) => (
              <Droppable droppableId={`${i}${j}`} key={`${i}${j}`}>
                {(provided, snapshot) => (
                  <CellComponent
                    key={`${cell.row}${cell.column}`}
                    cell={cell}
                    innerRef={provided.innerRef}
                    provided={provided}
                    isMoveInMade={isMoveInMade}
                    possibleMoves={possibleMoves}
                    imageLoader={imageLoader}
                    game={game}
                    handleClick={handleClick}
                  />
                )}
              </Droppable>
            ))
          )}
        </DragDropContext>
      </div>

      {promotionModale && game.toPromote ? (
        <>
          <div className="promotion-background"></div>
          <div className="promotion">
            <img
              className="piece"
              src={imageLoader.getImageByName(`${game.whoPlay.color}_knight`)}
              alt={"Knight"}
              onClick={() => setPromotionCall(game.toPromote, "N")}
            />
            <img
              className="piece"
              src={imageLoader.getImageByName(`${game.whoPlay.color}_bishop`)}
              alt={"Bishop"}
              onClick={() => setPromotionCall(game.toPromote, "B")}
            />
            <img
              className="piece"
              src={imageLoader.getImageByName(`${game.whoPlay.color}_rook`)}
              alt={"Rook"}
              onClick={() => setPromotionCall(game.toPromote, "R")}
            />
            <img
              className="piece"
              src={imageLoader.getImageByName(`${game.whoPlay.color}_queen`)}
              alt={"Queen"}
              onClick={() => setPromotionCall(game.toPromote, "Q")}
            />
          </div>
        </>
      ) : (
        <></>
      )}
    </div>
  );
};

export default Board;

// File: src/components/Board/CellComponent.jsx
import React from "react";
import { Draggable } from "react-beautiful-dnd";
export default function CellComponent({
  innerRef,
  provided,
  cell,
  isMoveInMade,
  possibleMoves,
  imageLoader,
  game,
  handleClick,
}) {
  return (
    <div
      ref={innerRef}
      className={`cell ${isMoveInMade(cell) && cell.color + "-move-made"} ${
        cell.color
      } `}
      onClick={() => handleClick(cell)}
    >
      <div />

      {!cell.isEmpty && (
        <Draggable
          draggableId={`${cell.row}${cell.column}${cell.piece.code}`}
          index={cell.row * 10 + cell.column}
        >
          {(provided, snapshot) => (
            <img
              ref={provided.innerRef}
              {...provided.draggableProps}
              {...provided.dragHandleProps}
              className={`piece ${
                game.player1.color === "black" && " reverse"
              }`}
              src={imageLoader.getImageByClass(cell.piece)}
              alt={cell.piece?.name}
            />
          )}
        </Draggable>
      )}
      {provided.placeholder}
      <div
        className={possibleMoves.includes(cell) ? "possible-moves" : ""}
      ></div>
    </div>
  );
}

// File: src/components/Game/WebSocketComponent.css
.game-view{
    min-height: 100vh;
    /* border: 1px solid white; */
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    /* overflow: scroll; */

}


.game-code-container{
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    /* border: 1px solid white; */
}
.game-code{
    font-size: 23px;
    /* padding-top: 1rem; */
    /* border: 1px solid white; */
    text-align: center;
    margin-bottom: 1rem;
    
}

.game-board-container{
    position: relative;
    margin: 20px;
    /* border: 1px solid white; */
    /* margin-top: 20px; */
}

.game-board{
    position: relative;
    /* margin-top: 20px; */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: fit-content;
    min-width: 350px;
    max-width: 600px;
    /* border: 1px solid white; */
    
}
.copy-btn{
    cursor: pointer;
    width: 30px;
    height: 30px;
}

.copy-btn:active{
    color:#81A64C
}

.menu{
    display: flex;
    padding: 10px;
    background-color: black;
}


.icon-bar-menu{
    width: 30px;
    cursor: pointer;
    margin-right: 10px;
}
@media screen and (max-width: 700px){
    .game-view{
        flex-direction: column;
        margin: auto;
    }

    .game-board-container{
        position: relative;
        margin: 20px;
        /* border: 1px solid white; */
        width: 100%;
        /* margin-top: 20px; */
    }
    
    
}
// File: src/components/Game/WebSocketComponent.tsx
import React, { useEffect, useState } from "react";
import Game from "../../core/config/Game.ts";
import Board from "../Board/Board.tsx";
import { Color, Move, NodeMove, ReMatch } from "../../core/types/Type.ts";
import Player from "../../core/types/Player.ts";
import "./WebSocketComponent.css";
import Modal from "../Modal/Modal.tsx";
import LoadingDot from "../../core/icons/LoadingDot.jsx";
import PlayerInfo from "../PlayerInfo/PlayerInfo.tsx";
import {
  GravityUiBars,
  GravityUiChevronLeft,
  GravityUiChevronRight,
  GravityUiCopy,
} from "../../core/icons/icons.jsx";
import SoundComponent from "../../core/sounds/SoundComponent.jsx";
import SoundManager from "../../core/sounds/SoundManager.jsx";
import { ImagesLoader } from "../../core/config/ImagesLoader.ts";

export interface GameProps {
  playerName: string;
  isHost: boolean;
  socket: WebSocket;
  closeSocket: (code?: number | undefined, reason?: string | undefined) => void;
  roomId: string;
}
const imageLoader = ImagesLoader.instance;
const WebSocketComponent: React.FC<GameProps> = ({
  playerName,
  isHost,
  socket,
  roomId,
  closeSocket,
}) => {
  const [messages, setMessages] = useState<string[]>([]);
  const [chess, setChess] = useState<Game | null>(null);
  const [fen, setFen] = useState("");
  const [move, setMove] = useState<Move | null>(null);
  const [startGame, setStartGame] = useState<boolean>(false);
  const [endGame, setEndGame] = useState<boolean>(false);
  const [endGameModal, setEndGameModal] = useState<boolean>(false);
  const [rematch, setRematch] = useState<ReMatch | null>(null); // define if there is a pendding rematch request
  const [timeLeftTo, setTimeLeftTo] = useState<number>(0);
  const [soundType, setSoundType] = useState(""); //Play sound after each moves

  socket.onopen = () => {
    console.log("connected");
  };

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = time % 60;
    return `${minutes < 10 ? "0" : ""}${minutes}:${
      seconds < 10 ? "0" : ""
    }${seconds}`;
  };

  socket.onmessage = (event) => {
    const data = JSON.parse(event.data);

    if (data.type === "move" && chess) {
      const moveSend = data.content.move;
      const startTime = data.content.startTime;
      const moveMaked = chess.move(moveSend);
      setMove(null);

      if (moveMaked) {
        setTimeLeftTo(startTime);
        setSoundType(moveMaked);
      }
    } else if (data.type === "findcolor") {
      // Player who join game send findcolor message to know is color and the send a response
      if (isHost && chess) {
        const opponent = data.content;
        chess.player2.name = opponent.name;

        setColor(chess.player1, chess.player2);
      }
    } else if (data.type === "setcolor") {
      // The host send the color of it's opponent and set is name on game parameters
      if (!isHost && !chess) {
        const players = data.content;
        const game = new Game(players.guest.name, players.guest.color);
        game.player2.name = players.host.name;

        setChess(game);
        sendStartGame();
      }
    } else if (data.type === "start") {
      // message send to start the game
      if (!chess) return;
      chess.isGameStart = true;
      setTimeLeftTo(data.content.startTime);
      const gameTime = data.content.time;
      chess.timers = { black: gameTime, white: gameTime };
      setEndGame(false);
      setStartGame(true);
    } else if (data.type === "rematch") {
      // Messge send to reset the game and send start request
      setStartGame(false);
      const rematch: ReMatch = data.content;
      setRematch(rematch);
      if (rematch.response) {
        chess?.reMatch();
        setRematch(null);
        sendStartGame();
      }
    }
  };

  const getMyColor = () => {
    if (socket) {
      const me = new Player();
      me.name = playerName;
      socket.send(
        JSON.stringify({
          type: "findcolor",
          content: me,
        })
      );
    }
  };

  const setColor = (host: Player, guest: Player) => {
    if (socket) {
      socket.send(
        JSON.stringify({
          type: "setcolor",
          content: { host, guest },
        })
      );
    }
  };

  const sendMove = (move: Move) => {
    if (socket && chess && chess.isValidMove2(move)) {
      socket.send(
        JSON.stringify({
          type: "move",
          content: move,
        })
      );
    }
  };

  const sendStartGame = () => {
    if (socket) {
      socket.send(
        JSON.stringify({
          type: "start",
          content: true,
        })
      );
    }
  };

  const sendRematch = (rematch: ReMatch) => {
    if (socket) {
      socket.send(
        JSON.stringify({
          type: "rematch",
          content: rematch,
        })
      );
    }
  };

  useEffect(() => {
    if (socket.OPEN) {
      if (isHost && !chess) {
        const color: Color[] = ["white", "black"];
        const random = Math.round(Math.random());
        setChess(new Game(playerName, color[random]));
      } else if (!isHost && !chess) {
        getMyColor();
      }
    }
  }, [socket]);

  useEffect(() => {
    if (move === null || !chess) return;
    // setFen(chess.generateFEN());
    sendMove(move);
  }, [chess, move]);

  useEffect(() => {
    if (startGame && chess) {
      chess.isGameStart = true;
    }
  }, [chess, startGame]);

  useEffect(() => {
    if (chess && chess.isGameOver()) {
      setEndGame(true);
    }
  }, [chess, chess?.whoPlay]);

  useEffect(() => {
    setEndGameModal(endGame);
  }, [endGame]);

  useEffect(() => {
    if (soundType) {
      const timeout = setTimeout(() => setSoundType(""), 500);
      return () => clearTimeout(timeout);
    }
  }, [soundType]);

  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };

  const applyMoveNode = (moveNode: NodeMove | null) => {
    if (!chess || moveNode == null || moveNode.state == null) return;
    const from = moveNode.state[0];
    const to = moveNode.state[1];
    chess.board[from.row][from.column] = from;
    chess.board[to.row][to.column] = to;
    setSoundType(moveNode.type);
  };

  return (
    <div className="game-view">
      <div className="game-code-container">
        <h1 className="game-code">Game Room: {roomId}</h1>
        <GravityUiCopy
          className="copy-btn"
          onClick={() => copyToClipboard(roomId)}
        />
      </div>
      <div className="sound">
        <SoundManager soundType={soundType} />
      </div>

      {chess ? (
        <div className="game-board-container">
          <div className="game-board">
            <PlayerInfo
              startGame={startGame}
              game={chess}
              player={chess.player2}
              setEndGame={setEndGame}
              startTimeDate={chess.isTurn(chess.player2) ? timeLeftTo : 0}
            />
            <Board game={chess} setMove={setMove} startGame={startGame} />
            <PlayerInfo
              game={chess}
              player={chess.player1}
              setEndGame={setEndGame}
              startGame={startGame}
              startTimeDate={chess.isTurn(chess.player1) ? timeLeftTo : 0}
            />
            <div className="menu">
              <GravityUiBars
                className="icon-bar-menu"
                onClick={() => setEndGameModal(true)}
              />
              {endGame ? (
                <GravityUiChevronLeft
                  className="icon-bar-menu"
                  onClick={() => applyMoveNode(chess.prevState())}
                />
              ) : (
                <></>
              )}
              {endGame ? (
                <GravityUiChevronRight
                  className="icon-bar-menu"
                  onClick={() => applyMoveNode(chess.nextState())}
                />
              ) : (
                <></>
              )}
            </div>
          </div>
          {endGameModal ? (
            <>
              <Modal
                title={
                  endGame
                    ? chess.getWinner()
                      ? `${chess.getWinner()?.color} win`
                      : "It's a draw"
                    : "Options"
                }
                onclick={setEndGameModal}
              >
                {chess.winner === null && endGame ? (
                  <div className="win">🫱🏿‍🫲🏻</div>
                ) : chess.winner === chess.player1 ? (
                  <div className="win">🎉</div>
                ) : chess.winner === chess.player2 ? (
                  <div className="win">😭</div>
                ) : (
                  <></>
                )}

                {rematch?.request ? (
                  rematch?.requester !== chess.player1.color ? (
                    <button
                      className="btn"
                      type="button"
                      onClick={() => {
                        const req: ReMatch = {
                          request: true,
                          requester: chess.whoPlay.color,
                          response: true,
                        };
                        sendRematch(req);
                      }}
                      style={{ marginTop: "1rem" }}
                    >
                      Accept Rematch
                    </button>
                  ) : (
                    <button className="btn" type="button">
                      <LoadingDot width={"40px"} />
                    </button>
                  )
                ) : (
                  <button
                    className="btn"
                    type="button"
                    onClick={() => {
                      const req: ReMatch = {
                        request: true,
                        requester: chess.player1.color,
                        response: false,
                      };
                      sendRematch(req);
                    }}
                    style={{ marginTop: "1rem" }}
                  >
                    Rematch
                  </button>
                )}
                <button
                  className="btn"
                  type="button"
                  onClick={() => {
                    closeSocket();
                  }}
                  style={{ marginTop: "1rem" }}
                >
                  Home
                </button>
              </Modal>
            </>
          ) : (
            <></>
          )}
        </div>
      ) : (
        <div></div>
      )}
    </div>
  );
};

export default WebSocketComponent;

// File: src/components/Layout/Layout.css
.layout{
    padding-bottom: env(safe-area-inset-bottom);
}
// File: src/components/Layout/Layout.jsx
import React, { useEffect, useState } from "react";
import CreateGame from "../Login/CreateGame.jsx";
import WebSocketComponent from "../Game/WebSocketComponent.tsx";
import { backendWebSocketUrl } from "../../core/config/backends.js";
import "./Layout.css";

export default function Layout() {
  const [socket, setSocket] = useState(null);
  const [playerName, setPlayerName] = useState("");
  const [isHost, setIsHost] = useState(false);
  const [roomName, setRoomName] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false);

  useEffect(() => {
    if (!roomName) return;

    setLoading(true);
    const ws = new WebSocket(`${backendWebSocketUrl}/ws/game/${roomName}/`);
    setSocket(ws);
  }, [roomName]);

  useEffect(() => {
    if (!socket) return;
    socket.onopen = () => {
      console.log("connected");
      setLoading(false);
    };

    socket.onclose = () => {
      setLoading(false);
      setSocket(null);
      console.log("closed");
    };

    socket.onerror = () => {
      setError(true);
      console.log("Error");
    };
  }, [socket]);

  return (
    <div className="layout">
      {socket && !loading && playerName ? (
        <WebSocketComponent
          isHost={isHost}
          playerName={playerName}
          socket={socket}
          roomId={roomName}
          closeSocket={() => socket.close()}
        />
      ) : (
        <CreateGame
          setPlayerName={setPlayerName}
          setIsHost={setIsHost}
          setRoomName={setRoomName}
          loading={loading}
        />
      )}
    </div>
  );
}

// File: src/components/Login/CreateGame.css
.container-home{
    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
    /* border: 1px solid white; */
}

.title-home{
    height: 80px;
    font-size: 1.2em;
    display: flex;
    justify-content: center;
    align-items: center;
}

.image-title{
    width: 50px;
    height: 50px;
}
.caption-home{
    max-width: 800px;
}

.description-home{
    margin: 20px;
}

.description-home h2{
   font-size:1.2em;
   text-align: center;
   line-height: 1.1em;
}
.description-home>li{
    margin-top: 20px;
}

.bold{
    font-weight:bold;
    font-size: 1.1em
}



.container-form-create-join{
  display: flex;
  /* border: 1px solid white; */
  flex-direction: column;
  align-items: center;
  min-width: 350px;
  width: 60%;
  max-width: 600px;
  margin-bottom: 20px;
  
}

.menu-create-join {
    /* border: 1px solid white; */
    margin: auto;
    display: flex;
    flex-direction: row;
    justify-content: start;
    min-width: 350px;

}
.create-join-content{
    aspect-ratio: 1;
    min-width: 350px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: #1E1D1A;
}

.textinput{
    width: 75%;
    border: none;
    height: 50px;
    margin-bottom: 20px;
    padding-left: 5%;
    font-size: 20px;
    border-radius: 5px;
    transition:  box-shadow 0.2s ease-out;
}

.textinput:focus{
    outline: none;
    box-shadow: inset 0px 0px 0px 2px #81A64C;
}
  
.tab {
    cursor: pointer;
    flex: 1;
    padding: 20px;
    text-align: center;
    font-size: 1em;
    font-weight: bold;
    background-color: #1A1A17;
    transition: background-color 0.2s ease-out;
}
/* 
.tab-inactive:hover{
    background-color: #302E2D;
    border:1px solid  rgb(225, 224, 240);
    
} */
  
.tab-active {
    background-color: #1E1D1A;
    /* border:1px solid  rgb(225, 224, 240); */
}

.btn{
    width: 80%;
    border: none;
    height: 50px;
    background-color: #81A64C;
    color: white;
    font-weight: bold;
    font-size: 1.1em;
    border-radius: 5px;
    transition: background-color 0.2s ease-out;
    margin-left: auto;
    margin-right: auto;
    cursor: pointer;
}

.btn:hover{
    background-color: rgb(129, 166, 76, 0.8);
}
  

.footer{
    padding: 10px;
    color: white;
    height:  50px;
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    align-items:center;

    margin-bottom: env(safe-area-inset-bottom);
  }
  
  .footer a {
    color: white;
  }
// File: src/components/Login/CreateGame.jsx
import React, { useEffect, useState } from "react";
import { backendUrl, backendWebSocketUrl } from "../../core/config/backends";
import "./CreateGame.css";
import LoadingDot from "../../core/icons/LoadingDot";

const CreateGame = ({ setRoomName, setPlayerName, setIsHost, loading }) => {
  const [name, setName] = useState("");
  const [hostName, setHostName] = useState("");
  const [loadingBtn, setLoadingBtn] = useState(loading);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState("create");
  const [webSocket, setWebSocket] = useState(null);

  useEffect(() => {
    setLoadingBtn(loading);
  }, [loading]);

  const handleTabClick = (section) => {
    setActiveTab(section);
  };

  const handleCreateGame = async () => {
    setError(null);
    try {
      const response = await fetch(`${backendUrl}/create_game/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });
      const data = await response.json();
      if (response.ok) {
        const host = data.room_id.split("-")[0];
        setHostName(host);
        setPlayerName(name);
        setIsHost(true);
        setRoomName(host);
      } else {
        setError(data.error || "Une erreur est survenue");
        setLoadingBtn(false);
      }
    } catch (err) {
      setError("Une erreur est survenue");
      setLoadingBtn(false);
    }
  };

  const joinGame = () => {
    setLoadingBtn(true);
    setPlayerName(name);
    setIsHost(false);
    setRoomName(hostName);
  };

  return (
    <div className="container-home">
      <div className="caption-home">
        <div className="title-home">
          <h1>AncaChess</h1>
          <img className="image-title" src="images/pions/Nw.png" alt="" />
        </div>

        <div className="description-home">
          <h2>Welcome to our online chess platform! </h2>
        </div>
      </div>

      <div className="container-form-create-join">
        <div className="menu-create-join">
          <div
            className={`tab ${
              activeTab === "create" ? "tab-active" : "tab-inactive"
            }`}
            onClick={() => handleTabClick("create")}
          >
            Create a Game
          </div>
          <div
            className={`tab ${
              activeTab === "join" ? "tab-active" : "tab-inactive"
            }`}
            onClick={() => handleTabClick("join")}
          >
            Join a Game
          </div>
        </div>

        {activeTab === "create" && (
          <div className="create-join-content">
            <input
              className="textinput"
              type="text"
              name="name"
              value={name}
              placeholder="Enter your name"
              onChange={(e) => setName(e.target.value)}
            />

            <button
              className="btn"
              type="button"
              onClick={() => {
                setLoadingBtn(true);
                handleCreateGame();
              }}
            >
              {!loadingBtn ? "Host game" : <LoadingDot width={"40px"} />}
            </button>
          </div>
        )}
        {activeTab === "join" && (
          <div className="create-join-content">
            <input
              className="textinput"
              type="text"
              name="name"
              value={name}
              placeholder="Enter your name"
              onChange={(e) => setName(e.target.value)}
            />
            <input
              className="textinput"
              name="codejoin"
              type="text"
              placeholder="Enter game code"
              value={hostName}
              onChange={(e) => setHostName(e.target.value)}
            />
            <button
              onClick={() => {
                setLoadingBtn(true);
                joinGame();
              }}
              className="btn"
              type="button"
            >
              {!loading ? "Join a game" : <LoadingDot width={"40px"} />}
            </button>
          </div>
        )}
      </div>
      <div className="footer">
        <span>
          👋 Hi I'm Antoine software engineer{" "}
          <a href="https://github.com/antoineTsinga"> Follow me on GitHub</a>
        </span>
      </div>
    </div>
  );
};

export default CreateGame;

// File: src/components/Modal/Modal.css
.modal{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.modal-background{
    width: 100%;
    height: 100%;
    
    display: flex;
    border: 1px solid black;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    background-color: rgb(0, 0, 0,0.8);
}

.modal-content{
    width: 400px;
    min-height: 50%;
    margin: 10px;
    background-color: white;
    color: black;
    border-radius: 10px;
    padding: 20px;
    transition: opacity 1s ease;
    display: flex;
    flex-direction: column;
    
}

.modal-header{
    display: flex;
    flex-direction: row;

}

.modal-title{
    flex: 1;
    font-size: 1.5em;
    font-weight: bold;
    text-align: center;
}

.modal-close-btn{
    cursor: pointer;
}
// File: src/components/Modal/Modal.tsx
import React from "react";
import "./Modal.css";
import { Close } from "../../core/icons/icons";

export default function Modal({ title, onclick, children }) {
  return (
    <div className="modal">
      <div className="modal-background">
        <div className="modal-content">
          <div className="modal-header">
            <div className="modal-title">{title}</div>
            <Close
              className="modal-close-btn"
              style={{ width: "2em" }}
              onClick={() => onclick(false)}
            />
          </div>
          {children}
        </div>
      </div>
    </div>
  );
}

// File: src/components/PlayerInfo/PlayerInfo.css
.section-player{
    width: 100%;
    font-weight: bold; 
    background-color: rgb(169, 182, 182);
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    max-width: 900px;
    user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.avater{
    width: 50px;
    height: 50px;
    background-color: aqua;
    margin: 5px;
}

.info-player{
    color: black;
    flex: 1;
    padding-left: 10px;
    height: 50px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.pieces{
    display: flex;
    flex-direction: row;

}

.item-piece-container{
    position: relative;
    width: 0;
    /* border: 1px solid black; */
}

.item-piece{
    position: relative;
    width: 1.5rem;
    /* border: 1px solid black; */
    margin-left: -1rem;
}

.timer{
    padding: 10px;
    text-align: center;
    width: 100px;
    height: fit-content;
    background-color: rgb(88, 97, 97);
    border-radius: 3px;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    margin: 10px;
}

.active{
    background-color: rgb(23, 23, 23);
}

.relative{
    display: flex;
    flex-direction: row;
    /* padding-right: 6%; */
    /* border: 1px solid black; */
    width:fit-content;
}






@media screen and (max-width: 700px){
    .item-piece{
        position: relative;
        width: 1.2rem;
        /* border: 1px solid black; */
        margin-left: -0.9rem;
    }
    
    .pieces span{
        font-size: 13px;
    }
    
    .timer{
        width: 80px;
    }
    
}
// File: src/components/PlayerInfo/PlayerInfo.tsx
import React, { useCallback, useEffect, useState } from "react";
import Game from "../../core/config/Game";
import Player from "../../core/types/Player";
import { Color } from "../../core/types/Type";
import "./PlayerInfo.css";
import { Clock } from "../../core/icons/icons";
import { ImagesLoader } from "../../core/config/ImagesLoader.ts";

export interface BoardProps {
  game: Game;
  player: Player;
  setEndGame: React.Dispatch<boolean>;
  startGame: boolean;
  startTimeDate: number;
}
const imageLoader = ImagesLoader.instance;
const PlayerInfo: React.FC<BoardProps> = ({
  game,
  player,
  setEndGame,
  startGame, // if the as start
  startTimeDate, // The date from which we start counting the time elapsed by the player
}) => {
  const [active, setActive] = useState<boolean>(false);
  const [time, setTime] = useState<number>(game.timers[player.color]);
  const [advantage, setAdvantage] = useState<number>(0);
  const [intervalId, setIntervalId] = useState<NodeJS.Timeout>();
  const colortakenPieces: Color = game.getOpponent(player).color;

  const countAdvantage = useCallback(
    (game: Game) => {
      const point = game
        .leftPieceTo(player)
        .reduce((p, p2) => p + p2.piece.value, 0);
      const adversary = game
        .leftPieceTo(game.getOpponent(player))
        .reduce((p, p2) => p + p2.piece.value, 0);

      return Math.max(0, point - adversary);
    },
    [player]
  );

  const interval = useCallback(() => {
    const now = Date.now() / 1000;
    setTime(game.timers[player.color] - (now - startTimeDate));
  }, [startTimeDate]);

  useEffect(() => {
    if (!startGame) return;

    if (game.isTurn(player)) {
      // start timer if turn to play
      setActive(true);
      setIntervalId(setInterval(interval, 50));
    } else {
      setActive(false);
      clearInterval(intervalId);
    }

    setAdvantage(countAdvantage(game));

    return () => clearInterval(intervalId);
  }, [countAdvantage, game, interval, player, startGame, startTimeDate]);

  useEffect(() => {
    if (time <= 0 || game.isGameOver()) {
      setTime(Math.max(0, time));
      game.timers[player.color] = 0;
      game.setWinner();
      setActive(false);
      setEndGame(true);
      clearInterval(intervalId);
    }
  }, [game, time]);

  useEffect(() => {
    setTime(game.timers[player.color]);
  }, [game.timers, player.color]);

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes < 10 ? "0" : ""}${minutes}:${
      seconds < 10 ? "0" : ""
    }${seconds}`;
  };

  const printPiece = (code: string) => {
    //add taken pieces
    let leftpixels = 1;
    return game.takenPieces[colortakenPieces]
      .filter((piece) => piece.code === code && piece.color !== player.color)
      .map((piece, index) => {
        leftpixels -= 0;
        const n =
          game.takenPieces[colortakenPieces].filter(
            (piece) => piece.code === code && piece.color !== player.color
          ).length - 1;
        return (
          <img
            key={index}
            className="item-piece"
            src={imageLoader.getImageByClass(piece)}
            alt={piece.name}
            style={{
              left: leftpixels + "rem",
              marginRight: index === n ? "20px" : 0,
            }}
          />
        );
      });
  };

  return (
    <div className="section-player">
      <img className="avater" src="/images/user.png" alt={player.name} />
      <div className="info-player">
        <span>
          {player.name ? player.name : "Waiting for your opponent..."}
        </span>
        <div className="pieces">
          <div className="pawn relative">{printPiece("P")}</div>
          <div className="knight relative">{printPiece("N")}</div>
          <div className="bishop relative">{printPiece("B")}</div>
          <div className="rook relative">{printPiece("R")}</div>
          <div className="queen relative">{printPiece("Q")}</div>
          <span>{advantage > 0 && "+" + advantage}</span>
        </div>
      </div>

      <div className={`timer ${active && time > 0 && "active"}`}>
        <Clock width={"1em"} style={{ opacity: active ? 1 : 0 }} />
        <span>{formatTime(time)}</span>
      </div>
    </div>
  );
};

export default PlayerInfo;

// File: src/core/config/backends.js
const backendUrl = process.env.REACT_APP_API_URL;
const backendWebSocketUrl = process.env.REACT_APP_BACKEND_WEBSOCKET_URL;

export { backendUrl, backendWebSocketUrl };

// File: src/core/config/Game.ts
import { BoardType, Color, Move, MoveType, NodeMove } from "../types/Type.ts";
import Player from "../types/Player.ts";
import { createBoard } from "./initialBoard.ts";
import IPiece from "../types/IPiece.ts";
import Cell from "../types/Cell.ts";
import { Bishop, Knight, Queen, Rook } from "./pieces/piece.ts";

export default class Game {
  player1: Player = new Player();
  player2: Player = new Player();
  hostCode: string;
  board: BoardType;
  history: string[] = [];
  historyMove: { start: NodeMove; end: NodeMove } = {
    start: new NodeMove(),
    end: new NodeMove(),
  };
  currentState: NodeMove;
  isGameStart: boolean = false;
  winner: Player | null = null;
  turn: number = 0;
  whoPlay: Player;
  toPromote: Cell | null = null;
  LastFiftyMoveWithoutTake: number[] = [];
  numberFullMoves: number = 1;
  timers: { black: number; white: number } = { black: 600, white: 600 };
  takenPieces: { black: IPiece[]; white: IPiece[] } = { black: [], white: [] };
  kingPos: { white: [number, number]; black: [number, number] } = {
    white: [7, 4],
    black: [0, 4],
  };

  constructor(namePlayer1: string, color: Color) {
    const colorOpponent: { black: Color; white: Color } = {
      black: "white",
      white: "black",
    };

    this.player1.color = color;
    this.player1.name = namePlayer1;
    this.player2.color = colorOpponent[color];

    this.whoPlay = color === "white" ? this.player1 : this.player2;
    this.hostCode = Math.random().toString();

    this.board = createBoard();
  }

  getOpponent(player: Player): Player {
    return this.player1 === player ? this.player2 : this.player1;
  }

  isTurn(player: Player): boolean {
    return this.whoPlay === player;
  }
  getTimer(player: Player): number {
    return this.timers[player.color];
  }

  isGameOver(): boolean {
    if (this.winner) return true;
    this.setWinner();
    return (
      this.isCheckMat(this.player1) ||
      this.isCheckMat(this.player2) ||
      this.isNull() ||
      this.timers.black <= 0 ||
      this.timers.white <= 0
    );
  }

  setWinner(): void {
    if (this.isCheckMat(this.player1) || this.timers[this.player1.color] <= 0) {
      this.winner = this.player2;
    }
    if (this.isCheckMat(this.player2) || this.timers[this.player2.color] <= 0) {
      this.winner = this.player1;
    }
  }
  getWinner(): Player | null {
    return this.winner;
  }

  reMatch(): void {
    if (this.player1.color === "black") {
      this.player1.color = "white";
      this.player2.color = "black";
      this.whoPlay = this.player1;
    } else {
      this.player2.color = "white";
      this.player1.color = "black";
      this.whoPlay = this.player2;
    }
    this.board = createBoard();
    this.history = [];
    this.historyMove = { start: new NodeMove(), end: new NodeMove() };
    this.currentState = new NodeMove();
    this.isGameStart = false;
    this.winner = null;
    this.turn = 1;
    this.toPromote = null;
    this.LastFiftyMoveWithoutTake = [];
    this.numberFullMoves = 1;
    this.takenPieces = { black: [], white: [] };
    this.timers = { black: 600, white: 600 };
    this.kingPos = {
      white: [7, 4],
      black: [0, 4],
    };
  }

  getkingCell(color: Color): Cell {
    const kingCell = this.board[this.kingPos[color][0]][this.kingPos[color][1]];
    return kingCell;
  }

  isCheckMat(player: Player): boolean {
    let onePieceCanMove = false;

    this.leftPieceTo(player).map((cell) => {
      onePieceCanMove = onePieceCanMove || this.canMove(cell);
      return 0;
    });
    return this.isInCheck(player) && !onePieceCanMove;
  }

  noPieceCanMove(player: Player): boolean {
    let noPieceCanMove = true;
    this.leftPieceTo(player).forEach((cell) => {
      noPieceCanMove = noPieceCanMove && !this.canMove(cell);
    });

    return noPieceCanMove;
  }

  canMove(cell: Cell): boolean {
    const possibleMoves = this.possibleMoveFrom(cell);
    return possibleMoves.length > 0;
  }

  leftPieceTo(player: Player): Cell[] {
    const leftPieces: Cell[] = [];
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        if (
          this.board[i][j].piece &&
          this.board[i][j].piece?.color === player.color
        ) {
          leftPieces.push(this.board[i][j]);
        }
      }
    }

    return leftPieces;
  }

  totalLeftPieces() {
    return (
      this.leftPieceTo(this.player1).length +
      this.leftPieceTo(this.player2).length
    );
  }

  isNull(): boolean {
    return (
      this.isPat() ||
      this.notEnougthMaterial() ||
      this.isRepetition() ||
      this.isFiftyMoveWithoutTake()
    );
  }
  isPat(): boolean {
    return (
      this.noPieceCanMove(this.player1) || this.noPieceCanMove(this.player2)
    );
  }

  prevState(): NodeMove | null {
    if (!this.isGameOver()) return null;
    const res = this.currentState.prevState;
    if (!res || !res.state) return null;
    this.currentState = res;
    return res;
  }

  nextState(): NodeMove | null {
    if (!this.isGameOver()) return null;
    const res = this.currentState.nextState;

    if (!res || !res.state) return null;
    this.currentState = res;
    return res;
  }

  notEnougthMaterial(): boolean {
    const notEnougthMaterials: (string | undefined)[] = [
      "K",
      "KN",
      "NK",
      "KB",
      "BK",
    ];

    const leftPiecesPlayer1 = this.leftPieceTo(this.player1).map(
      (cell) => cell.piece?.code
    );

    const leftPiecesPlayer2 = this.leftPieceTo(this.player2).map(
      (cell) => cell.piece?.code
    );

    return (
      notEnougthMaterials.includes(leftPiecesPlayer1.join("")) &&
      notEnougthMaterials.includes(leftPiecesPlayer2.join(""))
    );
  }

  takeEnPassant(from: Cell, to: Cell): void {
    from.piece.enPassant = null;
    to.piece = from.piece;
    this.board[from.row][to.column].piece = null;
    from.piece = null;
  }

  isInCheck(player: Player): boolean {
    const kingCell: Cell = this.getkingCell(player.color);
    return (
      !this.noQueenOrBishopTargetingThisCellForKing(
        kingCell,
        kingCell,
        kingCell
      ) ||
      !this.noQueenOrRookTargetingThisCellForKing(
        kingCell,
        kingCell,
        kingCell
      ) ||
      !this.noPawnTargetingThisCellForKing(kingCell, kingCell, kingCell) ||
      !this.noKnightTargetingThisCellForKing(kingCell, kingCell, kingCell) ||
      !this.noKingTargetingThisCellForKing(kingCell, kingCell, kingCell)
    );
  }

  isRepetition(): boolean {
    const state: string = this.stringifyBoard();
    const repetitions = this.history.filter(
      (position) => position === state
    ).length;

    return repetitions >= 3; //there are already 2 states equal to the current state in history so it's repetion
  }

  stringifyBoard(): string {
    return JSON.stringify(
      this.board.map((rows) =>
        rows.map((cell) => {
          if (cell.isEmpty) {
            return "X";
          } else {
            return cell.piece?.code;
          }
        })
      )
    );
  }

  isFiftyMoveWithoutTake(): boolean {
    return (
      this.LastFiftyMoveWithoutTake.length >= 50 &&
      this.LastFiftyMoveWithoutTake.filter(
        (leftPiece) => leftPiece !== this.LastFiftyMoveWithoutTake[0]
      ).length === 0
    );
  }

  isPromotion(from: Cell, to: Cell): boolean {
    if (
      this.isValidMove(from, to) &&
      from.piece?.code === "P" &&
      (to.row === 0 || to.row === 7)
    ) {
      this.toPromote = to;

      return true;
    }

    return false;
  }

  changeTurn() {
    this.whoPlay = this.whoPlay === this.player1 ? this.player2 : this.player1;
  }

  possibleMoveFrom(cell: Cell) {
    if (cell.piece == null) {
      return [];
    }
    let possibleMoves = cell.piece?.getPossiblesMove(cell, this.board);

    if (cell.piece.enPassant != null) {
      const cellEnPassant =
        this.board[(cell.row + cell.piece.enPassant.row) / 2][
          cell.piece.enPassant.column
        ];
      possibleMoves.push(cellEnPassant);
    }

    possibleMoves = possibleMoves?.filter((to) =>
      this.kingIsSafeWhenPieceMoveFromTo(cell, to)
    );

    return possibleMoves;
  }

  isValidMove(from: Cell, to: Cell): boolean {
    const possibleMoves = this.possibleMoveFrom(from);
    return possibleMoves?.includes(to);
  }

  isValidMove2(move: Move): boolean {
    const from = this.board[move.from[0]][move.from[1]];
    const to = this.board[move.to[0]][move.to[1]];
    const possibleMoves = this.possibleMoveFrom(from);
    return possibleMoves?.includes(to);
  }

  copyInstance(instance) {
    const copy = new instance.constructor();
    for (let key in instance) {
      if (instance.hasOwnProperty(key)) {
        copy[key] = instance[key];
      }
    }
    return copy;
  }

  movePieceFromCellTo(
    from: Cell,
    to: Cell,
    promotion: string | null = null
  ): Move | null {
    if (!from.piece || !this.isValidMove(from, to)) return null;

    to.piece && this.takenPieces[to.piece.color].push(to.piece); // add in stack when taken pieces

    if (from.piece.code === "P") {
      this.makePawnMove(from, to, promotion);
    } else if (
      from.piece.code === "K" &&
      Math.abs(from.column - to.column) === 2 // move from two cells roque
    ) {
      this.makeRoqueMove(from, to);
    } else {
      from.movePieceTo(to);
    }

    if (
      this.LastFiftyMoveWithoutTake.length > 0 &&
      this.LastFiftyMoveWithoutTake[0] === this.totalLeftPieces()
    ) {
      this.LastFiftyMoveWithoutTake.push(this.totalLeftPieces());
    } else {
      this.LastFiftyMoveWithoutTake = [this.totalLeftPieces()];
    }

    this.history.push(this.stringifyBoard());

    const move = {
      from: [from.row, from.column],
      to: [to.row, to.column],
      promotion,
      timer: this.timers[this.whoPlay.color],
      color: this.whoPlay.color,
    };

    if (this.whoPlay.color === "black") this.numberFullMoves += 1; //count full moves
    this.turn += 1;
    this.changeTurn(); //change turn

    if (to.piece?.code === "K") {
      //update king position
      this.kingPos[to.piece.color] = [to.row, to.column];
    }

    if (this.isGameOver()) {
      this.setWinner();
    }

    return move;
  }

  makePawnMove(from: Cell, to: Cell, promotion: string | null = null) {
    if (
      (from.row === 6 && to.row === 4) || // some pieces can possibly make an enpassant
      (from.row === 1 && to.row === 3)
    ) {
      from.piece?.getNeighbors(this.board, to.row, to.column).map((cell) => {
        //add possible move to adjacent pawn
        cell.piece.enPassant = this.board[from.row][from.column];
      });
    }
    if (
      from.piece?.enPassant &&
      this.board[to.row][from.piece?.enPassant.column] === to
    ) {
      this.takeEnPassant(from, to);
    } else {
      //after a move enPassent can no longer be possible to the same pawn
      from.piece.enPassant = null;
      from.movePieceTo(to);
    }

    if (promotion) {
      this.setPromotion(to, promotion);
    }
  }

  move({ from, to, promotion, timer, color }: Move): string {
    const fromCell = this.board[from[0]][from[1]];
    const toCell = this.board[to[0]][to[1]];
    this.timers[color] = timer;

    const isCastle =
      fromCell?.piece?.code === "K" &&
      Math.abs(fromCell.column - toCell.column) === 2;

    const isCapture = !toCell.isEmpty;

    let type = MoveType.WRONG;

    const initState = [this.copyInstance(fromCell), this.copyInstance(toCell)];

    const res = this.movePieceFromCellTo(fromCell, toCell, promotion); // this methode will change fromCell and to Cell

    if (res) {
      if (this.isInCheck(this.whoPlay)) {
        type = MoveType.CHECK;
      } else if (isCastle) {
        type = MoveType.CASTLE;
      } else if (promotion) {
        type = MoveType.PROMOTE;
      } else if (!isCapture) {
        type = MoveType.MOVE;
      } else if (isCapture) {
        type = MoveType.CAPTURE;
      }
    }

    if (type !== MoveType.WRONG && res) {
      const start = new NodeMove();
      const end = new NodeMove();

      start.state = initState;
      start.nextState = end;
      start.type = this.historyMove.end.type;
      start.prevState = this.historyMove.start;
      start.currentMove = this.historyMove.end.currentMove;

      end.state = [this.copyInstance(fromCell), this.copyInstance(toCell)];
      end.type = type;
      end.prevState = start;
      end.currentMove = [
        this.copyInstance(fromCell),
        this.copyInstance(toCell),
      ];

      this.historyMove.end.nextState = end;

      this.historyMove = { start: start, end: end };
      this.currentState = end;
    }

    return type;
  }

  getImage = (type: string, colorChar0: string) =>
    `/images/pions/${type + colorChar0}.png`;

  setPromotion(cell: Cell, code: string) {
    const color = cell.piece.color;
    switch (code) {
      case "N":
        cell.piece = new Knight(color, this.getImage("N", color.charAt(0)));
        break;

      case "B":
        cell.piece = new Bishop(color, this.getImage("B", color.charAt(0)));
        break;

      case "R":
        cell.piece = new Rook(color, this.getImage("R", color.charAt(0)));
        break;
      case "Q":
        cell.piece = new Queen(color, this.getImage("Q", color.charAt(0)));
        break;
    }
    this.toPromote = null;
  }

  makeRoqueMove(from: Cell, to: Cell) {
    from.movePieceTo(to);
    if (to.column === 6) {
      //"small roque"
      this.board[from.row][5].piece = this.board[from.row][7].piece;
      this.board[from.row][7].piece = null;
    }
    if (to.column === 2) {
      //"big roque"
      this.board[from.row][3].piece = this.board[from.row][0].piece;
      this.board[from.row][0].piece = null;
    }
  }

  kingIsSafeWhenPieceMoveFromTo(from: Cell, to: Cell): boolean {
    const kingCell =
      this.board[this.kingPos[from.piece.color][0]][
        this.kingPos[from.piece.color][1]
      ];
    if (from.piece?.code === "K") {
      //check if there is no danger for the king to move to the cell "to"
      const isCastle = Math.abs(from.column - to.column) === 2;

      if (
        isCastle &&
        !this.kingIsSafeWhenPieceMoveFromTo(
          from,
          this.board[to.row][(to.column + from.column) / 2]
        )
      ) {
        return false;
      }
      return (
        this.noQueenOrBishopTargetingThisCellForKing(to, from, to) &&
        this.noQueenOrRookTargetingThisCellForKing(to, from, to) &&
        this.noPawnTargetingThisCellForKing(to, from, to) &&
        this.noKnightTargetingThisCellForKing(to, from, to) &&
        this.noKingTargetingThisCellForKing(to, from, to)
      );
    } else {
      //check if move a piece don't put the king in danger
      return (
        this.noQueenOrBishopTargetingThisCellForKing(kingCell, from, to) &&
        this.noQueenOrRookTargetingThisCellForKing(kingCell, from, to) &&
        this.noPawnTargetingThisCellForKing(kingCell, from, to) &&
        this.noKnightTargetingThisCellForKing(kingCell, from, to)
      );
    }
  }

  /**
   * return false if after the move the king is in danger targeting by a bishop or a queen
   * @param kingCell Cell where the king is after the move
   * @param movingPieceFrom Cell where the piece is before the move
   * @param movingPieceTo Cell where the piece is before the after the move
   * @returns
   */

  noQueenOrBishopTargetingThisCellForKing(
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    const directions = [
      [1, -1],
      [-1, 1],
      [1, 1],
      [-1, -1],
    ];

    return this.noPieceWhiteManyMovesByDirection(
      directions,
      ["B", "Q"],
      kingCell,
      movingPieceFrom,
      movingPieceTo
    );
  }

  /**
   * return false if after the move the king is in danger targeting by a rook or a queen
   * @param kingCell Cell where the king is after the move
   * @param movingPieceFrom Cell where the piece is before the move
   * @param movingPieceTo Cell where the piece is before the after the move
   * @returns
   */
  noQueenOrRookTargetingThisCellForKing(
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    const directions = [
      [0, -1],
      [0, 1],
      [1, 0],
      [-1, 0],
    ];

    return this.noPieceWhiteManyMovesByDirection(
      directions,
      ["R", "Q"],
      kingCell,
      movingPieceFrom,
      movingPieceTo
    );
  }

  /**
   * return false if the king is in danger targeting by a pawn after a move of the piece of same color
   * @param kingCell Cell where the king is after the move
   * @param movingPieceFrom Cell where the piece is before the move
   * @param movingPieceTo Cell where the piece is before the after the move
   * @returns
   */

  noPawnTargetingThisCellForKing(
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    const directions =
      movingPieceFrom.piece?.color === "white"
        ? [
            [1, -1],
            [-1, -1],
          ]
        : [
            [-1, 1],
            [1, 1],
          ];

    return this.noPieceWhiteOneMoveByDirection(
      directions,
      "P",
      kingCell,
      movingPieceFrom,
      movingPieceTo
    );
  }

  /**
   * return false if the king is in danger targeting by knight after a move of the piece of same color
   * @param kingCell Cell where the king is after the move
   * @param movingPieceFrom Cell where the piece is before the move
   * @param movingPieceTo Cell where the piece is before the after the move
   * @returns
   */

  noKnightTargetingThisCellForKing(
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    const directions = [
      [2, 1],
      [2, -1],
      [1, 2],
      [1, -2],
      [-2, 1],
      [-2, -1],
      [-1, 2],
      [-1, -2],
    ];

    return this.noPieceWhiteOneMoveByDirection(
      directions,
      "N",
      kingCell,
      movingPieceFrom,
      movingPieceTo
    );
  }
  noKingTargetingThisCellForKing(
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    const directions = [
      [1, 1],
      [1, -1],
      [-1, 1],
      [-1, -1],
      [0, 1],
      [0, -1],
      [-1, 0],
      [1, 0],
    ];

    return this.noPieceWhiteOneMoveByDirection(
      directions,
      "K",
      kingCell,
      movingPieceFrom,
      movingPieceTo
    );
  }
  /**
   *  return false if the king is in danger targeting by a piece with one move by direction, after a move of the piece of same color
   * @param directions all possible direction from witch the king can get targeting by the piece
   * @param code the code of the piece targeting
   * @param kingCell Cell where the king is after the move
   * @param movingPieceFrom Cell where the piece is before the move
   * @param movingPieceTo Cell where the piece is before the after the move
   * @returns
   */
  noPieceWhiteOneMoveByDirection(
    directions: number[][],
    code: string,
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    for (const [dx, dy] of directions) {
      const next_row = kingCell.row + dy;
      const next_col = kingCell.column + dx;
      if (!(0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8)) {
        continue;
      }

      if (!this.board[next_row][next_col].isEmpty) {
        if (this.board[next_row][next_col] === movingPieceTo) {
          // piece can take to protege the king
          continue;
        }

        if (
          this.board[next_row][next_col].piece?.code === code &&
          movingPieceFrom.piece?.color !==
            this.board[next_row][next_col].piece?.color
        ) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   *  return false if the king is in danger targeting by a piece with many move by direction, after a move of the piece of same color
   * @param directions all possible direction from witch the king can get targeting by the piece
   * @param code the code of the piece targeting
   * @param kingCell Cell where the king is after the move
   * @param movingPieceFrom Cell where the piece is before the move
   * @param movingPieceTo Cell where the piece is before the after the move
   * @returns
   */
  noPieceWhiteManyMovesByDirection(
    directions: number[][],
    code: string[],
    kingCell: Cell,
    movingPieceFrom: Cell,
    movingPieceTo: Cell
  ): boolean {
    for (const [dx, dy] of directions) {
      let next_row = kingCell.row;
      let next_col = kingCell.column;
      while (0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8) {
        next_row += dy;
        next_col += dx;

        if (!(0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8)) {
          break;
        }

        if (!this.board[next_row][next_col].isEmpty) {
          if (this.board[next_row][next_col] === movingPieceFrom) {
            // we supose that the piece had moved and there is no piece there
            continue;
          } else if (this.board[next_row][next_col] === movingPieceTo) {
            // piece can take to protege the king
            break;
          }

          if (
            movingPieceFrom.piece.color !==
              this.board[next_row][next_col].piece?.color &&
            code.includes(this.board[next_row][next_col].piece.code)
          ) {
            return false;
          } else {
            break;
          }
        } else {
          if (this.board[next_row][next_col] === movingPieceTo) {
            // New position cover the king
            break;
          }
        }
      }
    }
    return true;
  }

  generateFEN(): string {
    const board = this.board.map((cellRow) =>
      cellRow.map((cell) => {
        if (!cell.piece) return "";
        const symbol =
          cell.piece.color === "black"
            ? cell.piece.code.toLowerCase()
            : cell.piece.code;
        return symbol;
      })
    );
    let castlingRights = "";
    let enPassant = "-";

    const pieces = this.board.flat().filter((cell) => cell.piece);

    // Déterminer les droits de roque
    const whiteKing = pieces.find(
      (p) => p.piece?.code === "K" && p.piece.color === "white"
    );
    const blackKing = pieces.find(
      (p) => p.piece?.code === "K" && p.piece.color === "black"
    );
    const whiteRooks = pieces.filter(
      (p) => p.piece?.code === "R" && p.piece.color === "white"
    );
    const blackRooks = pieces.filter(
      (p) => p.piece?.code === "R" && p.piece.color === "black"
    );

    if (whiteKing && whiteKing.piece && whiteKing.piece.isFirstMove) {
      if (
        whiteRooks.some(
          (r) => r.row === 7 && r.column === 7 && r.piece?.isFirstMove
        )
      ) {
        castlingRights += "K";
      }
      if (
        whiteRooks.some(
          (r) => r.row === 7 && r.column === 0 && r.piece?.isFirstMove
        )
      ) {
        castlingRights += "Q";
      }
    }
    if (blackKing && blackKing.piece && blackKing.piece.isFirstMove) {
      if (
        blackRooks.some(
          (r) => r.row === 0 && r.column === 7 && r.piece?.isFirstMove
        )
      )
        castlingRights += "k";
      if (
        blackRooks.some(
          (r) => r.row === 0 && r.column === 0 && r.piece?.isFirstMove
        )
      )
        castlingRights += "q";
    }

    if (!castlingRights) castlingRights = "-";

    // Déterminer la prise en passant
    const enPassantPawn = pieces.find(
      (p) => p.piece?.code === "P" && p.piece.enPassant
    );
    if (enPassantPawn && enPassantPawn.piece) {
      const enPassantRow =
        enPassantPawn.piece.color === "white"
          ? enPassantPawn.row - 1
          : enPassantPawn.row + 1;
      const enPassantCol = enPassantPawn.column;
      enPassant = `${String.fromCharCode("a".charCodeAt(0) + enPassantCol)}${
        8 - enPassantRow
      }`;
    }

    // Générer la partie position de la FEN
    const fenPosition = board
      .map((row) => {
        let emptyCount = 0;
        return (
          row
            .map((square) => {
              if (square === "") {
                emptyCount++;
                return "";
              } else {
                const result =
                  emptyCount > 0 ? `${emptyCount}${square}` : square;
                emptyCount = 0;
                return result;
              }
            })
            .join("") + (emptyCount > 0 ? emptyCount : "")
        );
      })
      .join("/");

    // Combiner toutes les parties pour former la FEN
    return `${fenPosition} ${this.whoPlay.color.charAt(
      0
    )} ${castlingRights} ${enPassant} ${this.LastFiftyMoveWithoutTake.length} ${
      this.numberFullMoves
    }`;
  }
}

// File: src/core/config/ImagesLoader.ts
// Importez les images
import blackKing from "./pions/black_king.png";
import blackQueen from "./pions/black_queen.png";
import blackBishop from "./pions/black_bishop.png";
import blackKnight from "./pions/black_knight.png";
import blackRook from "./pions/black_rook.png";
import blackPawn from "./pions/black_pawn.png";

import whiteKing from "./pions/white_king.png";
import whiteQueen from "./pions/white_queen.png";
import whiteBishop from "./pions/white_bishop.png";
import whiteKnight from "./pions/white_knight.png";
import whiteRook from "./pions/white_rook.png";
import whitePawn from "./pions/white_pawn.png";
import IPiece from "../types/IPiece";

export class ImagesLoader {
  static #instance: ImagesLoader;
  private images: { [key: string]: string } = {};

  private constructor() {
    this.loadImages();
  }

  public static get instance(): ImagesLoader {
    if (!ImagesLoader.#instance) {
      ImagesLoader.#instance = new ImagesLoader();
    }
    return ImagesLoader.#instance;
  }

  private loadImages(): void {
    // Charger les images dans l'objet `images`
    this.images["black_king"] = blackKing;
    this.images["black_queen"] = blackQueen;
    this.images["black_bishop"] = blackBishop;
    this.images["black_knight"] = blackKnight;
    this.images["black_rook"] = blackRook;
    this.images["black_pawn"] = blackPawn;

    this.images["white_king"] = whiteKing;
    this.images["white_queen"] = whiteQueen;
    this.images["white_bishop"] = whiteBishop;
    this.images["white_knight"] = whiteKnight;
    this.images["white_rook"] = whiteRook;
    this.images["white_pawn"] = whitePawn;
  }

  public getImageByName(name: string): string | undefined {
    return this.images[name];
  }

  public getImageByClass(piece: IPiece | null): string | undefined {
    if (!piece) return undefined;
    const name = `${piece.color}_${piece.name.toLocaleLowerCase()}`;
    return this.images[name];
  }
}

// File: src/core/config/initialBoard.ts

import Cell  from "../types/Cell.ts";
import { initialPositions } from "./variables/pieces.ts";


function createBoard() {
  const board = new Array<Cell[]>(8);

  for (let row = 0; row < 8; row++) {
    board[row] = new Array(8);
    for (let col = 0; col < 8; col++) {
      board[row][col] = new Cell(
        row,
        col,
        (row + col) % 2 === 1 ? "black" : "white",
        board
      );
    }
  }

  for (let row in initialPositions) {
    for (let col = 0; col < 8; col++) {
      board[row][col].piece = initialPositions[row][col];
    }
  }
  return board;
}

export { createBoard };

// File: src/core/config/pieces/piece.ts

import King from "../../types/King.ts";
import Queen from "../../types/Queen.ts";
import Bishop from "../../types/Bishop.ts";
import Knight from "../../types/Knight.ts";
import Rook from "../../types/Rook.ts";
import Pawn from "../../types/Pawn.ts";


export {King, Queen, Bishop, Knight, Rook, Pawn} 
// File: src/core/config/utils.ts
import Game from "./Game.ts";

import Cell from "../types/Cell.ts";
import { Move } from "../types/Type.ts";

type SetterListCell = (moves: Cell[]) => void;

type SetterCell = (cell: Cell | null) => void;
type SetterBoolean = (value: boolean) => void;

/**
 * Show possibles moves that a the piece in a specific can make
 * @param cell cell contening the piece we want to see move
 * @param game game manager
 * @param setPossibleMoves setter to update the state
 * @param setPrevCell setter to update the state
 */
const showPosibleMove = (
  cell: Cell,
  game: Game,
  setPossibleMoves: SetterListCell,
  setPrevCell: SetterCell
) => {
  setPossibleMoves(game.possibleMoveFrom(cell));
  setPrevCell(cell);
};

/**
 * Move piece from cell to an other one
 * @param from
 * @param to
 * @param promotion
 * @param game
 * @param setPossibleMoves
 * @param setPrevCell
 * @returns
 */
const makeMove = (
  from: Cell,
  to: Cell,
  game: Game,
  setPossibleMoves: SetterListCell,
  setPrevCell: SetterCell,
  setCurrentPlayerMove: React.Dispatch<React.SetStateAction<Move | null>>
) => {
  if (!from || to === from || to?.piece?.color === from?.piece?.color) {
    showPosibleMove(to, game, setPossibleMoves, setPrevCell);
    return;
  }
  setPossibleMoves([]);

  const move: Move = {
    from: [from.row, from.column],
    to: [to.row, to.column],
    promotion: null,
    timer: game.getTimer(game.whoPlay),
    color: game.whoPlay.color,
  };

  setCurrentPlayerMove(move);
  setPrevCell(null);
};

export { showPosibleMove, makeMove };

// File: src/core/config/variables/pieces.ts
import { Bishop, King, Knight, Pawn, Queen, Rook } from "../pieces/piece.ts";

const whiteRook1 = new Rook("white", "/images/pions/Rw.png");
const whiteKnight1 = new Knight("white", "/images/pions/Nw.png");
const whiteBishop1 = new Bishop("white", "/images/pions/Bw.png");
const whiteQueen = new Queen("white", "/images/pions/Qw.png");
const whiteKing = new King("white", "/images/pions/Kw.png");
const whiteBishop2 = new Bishop("white", "/images/pions/Bw.png");
const whiteKnight2 = new Knight("white", "/images/pions/Nw.png");
const whiteRook2 = new Rook("white", "/images/pions/Rw.png");

const blackRook1 = new Rook("black", "/images/pions/Rb.png");
const blackRook2 = new Rook("black", "/images/pions/Rb.png");
const blackKnight1 = new Knight("black", "/images/pions/Nb.png");
const blackKnight2 = new Knight("black", "/images/pions/Nb.png");
const blackBishop1 = new Bishop("black", "/images/pions/Bb.png");
const blackBishop2 = new Bishop("black", "/images/pions/Bb.png");
const blackQueen = new Queen("black", "/images/pions/Qb.png");
const blackKing = new King("black", "/images/pions/Kb.png");

const whitePawn1 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn2 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn3 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn4 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn5 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn6 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn7 = new Pawn("white", "/images/pions/Pw.png");
const whitePawn8 = new Pawn("white", "/images/pions/Pw.png");

const blackPawn1 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn2 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn3 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn4 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn5 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn6 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn7 = new Pawn("black", "/images/pions/Pb.png");
const blackPawn8 = new Pawn("black", "/images/pions/Pb.png");

const initialPositions = {
  0: [
    blackRook1,
    blackKnight1,
    blackBishop1,
    blackQueen,
    blackKing,
    blackBishop2,
    blackKnight2,
    blackRook2,
  ],
  1: [
    blackPawn1,
    blackPawn2,
    blackPawn3,
    blackPawn4,
    blackPawn5,
    blackPawn6,
    blackPawn7,
    blackPawn8,
  ],
  6: [
    whitePawn1,
    whitePawn2,
    whitePawn3,
    whitePawn4,
    whitePawn5,
    whitePawn6,
    whitePawn7,
    whitePawn8,
  ],
  7: [
    whiteRook1,
    whiteKnight1,
    whiteBishop1,
    whiteQueen,
    whiteKing,
    whiteBishop2,
    whiteKnight2,
    whiteRook2,
  ],
};

export { initialPositions };

// File: src/core/icons/icons.jsx
import LoadingDot from "./LoadingDot";

const Clock = (props) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1em"
      height="1em"
      viewBox="0 0 16 16"
      {...props}
    >
      <path
        fill="currentColor"
        fillRule="evenodd"
        d="M13.5 8a5.5 5.5 0 1 1-11 0a5.5 5.5 0 0 1 11 0M15 8A7 7 0 1 1 1 8a7 7 0 0 1 14 0M8.75 4.5a.75.75 0 0 0-1.5 0V8a.75.75 0 0 0 .3.6l2 1.5a.75.75 0 1 0 .9-1.2l-1.7-1.275z"
        clipRule="evenodd"
      />
    </svg>
  );
};

const Close = (props) => {
  return (
    <svg {...props} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
      <path
        fill="currentColor"
        d="M195.2 195.2a64 64 0 0 1 90.496 0L512 421.504L738.304 195.2a64 64 0 0 1 90.496 90.496L602.496 512L828.8 738.304a64 64 0 0 1-90.496 90.496L512 602.496L285.696 828.8a64 64 0 0 1-90.496-90.496L421.504 512L195.2 285.696a64 64 0 0 1 0-90.496"
      />
    </svg>
  );
};

const GravityUiCopy = (props) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" {...props}>
      <path
        fill="currentColor"
        fillRule="evenodd"
        d="M12 2.5H8A1.5 1.5 0 0 0 6.5 4v1H8a3 3 0 0 1 3 3v1.5h1A1.5 1.5 0 0 0 13.5 8V4A1.5 1.5 0 0 0 12 2.5M11 11h1a3 3 0 0 0 3-3V4a3 3 0 0 0-3-3H8a3 3 0 0 0-3 3v1H4a3 3 0 0 0-3 3v4a3 3 0 0 0 3 3h4a3 3 0 0 0 3-3zM4 6.5h4A1.5 1.5 0 0 1 9.5 8v4A1.5 1.5 0 0 1 8 13.5H4A1.5 1.5 0 0 1 2.5 12V8A1.5 1.5 0 0 1 4 6.5"
        clipRule="evenodd"
      ></path>
    </svg>
  );
};

const GravityUiBars = (props) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" {...props}>
      <path
        fill="currentColor"
        fillRule="evenodd"
        d="M1.25 3.25A.75.75 0 0 1 2 2.5h12A.75.75 0 0 1 14 4H2a.75.75 0 0 1-.75-.75m0 4.75A.75.75 0 0 1 2 7.25h12a.75.75 0 0 1 0 1.5H2A.75.75 0 0 1 1.25 8M2 12a.75.75 0 0 0 0 1.5h12a.75.75 0 0 0 0-1.5z"
        clipRule="evenodd"
      ></path>
    </svg>
  );
};

function GravityUiChevronRight(props) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" {...props}>
      <path
        fill="currentColor"
        fillRule="evenodd"
        d="M5.47 13.03a.75.75 0 0 1 0-1.06L9.44 8L5.47 4.03a.75.75 0 0 1 1.06-1.06l4.5 4.5a.75.75 0 0 1 0 1.06l-4.5 4.5a.75.75 0 0 1-1.06 0"
        clipRule="evenodd"
      ></path>
    </svg>
  );
}

function GravityUiChevronLeft(props) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" {...props}>
      <path
        fill="currentColor"
        fillRule="evenodd"
        d="M10.53 2.97a.75.75 0 0 1 0 1.06L6.56 8l3.97 3.97a.75.75 0 1 1-1.06 1.06l-4.5-4.5a.75.75 0 0 1 0-1.06l4.5-4.5a.75.75 0 0 1 1.06 0"
        clipRule="evenodd"
      ></path>
    </svg>
  );
}
export {
  Clock,
  Close,
  LoadingDot,
  GravityUiCopy,
  GravityUiBars,
  GravityUiChevronRight,
  GravityUiChevronLeft,
};

// File: src/core/icons/LoadingDot.jsx
const LoadingDot = (props) => {
  return (
    <svg {...props} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <circle cx="4" cy="12" r="0" fill="currentColor">
        <animate
          fill="freeze"
          attributeName="r"
          begin="0;svgSpinners3DotsMove1.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="0;3"
        />
        <animate
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove7.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="4;12"
        />
        <animate
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove5.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="12;20"
        />
        <animate
          id="svgSpinners3DotsMove0"
          fill="freeze"
          attributeName="r"
          begin="svgSpinners3DotsMove3.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="3;0"
        />
        <animate
          id="svgSpinners3DotsMove1"
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove0.end"
          dur="0.001s"
          values="20;4"
        />
      </circle>
      <circle cx="4" cy="12" r="3" fill="currentColor">
        <animate
          fill="freeze"
          attributeName="cx"
          begin="0;svgSpinners3DotsMove1.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="4;12"
        />
        <animate
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove7.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="12;20"
        />
        <animate
          id="svgSpinners3DotsMove2"
          fill="freeze"
          attributeName="r"
          begin="svgSpinners3DotsMove5.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="3;0"
        />
        <animate
          id="svgSpinners3DotsMove3"
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove2.end"
          dur="0.001s"
          values="20;4"
        />
        <animate
          fill="freeze"
          attributeName="r"
          begin="svgSpinners3DotsMove3.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="0;3"
        />
      </circle>
      <circle cx="12" cy="12" r="3" fill="currentColor">
        <animate
          fill="freeze"
          attributeName="cx"
          begin="0;svgSpinners3DotsMove1.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="12;20"
        />
        <animate
          id="svgSpinners3DotsMove4"
          fill="freeze"
          attributeName="r"
          begin="svgSpinners3DotsMove7.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="3;0"
        />
        <animate
          id="svgSpinners3DotsMove5"
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove4.end"
          dur="0.001s"
          values="20;4"
        />
        <animate
          fill="freeze"
          attributeName="r"
          begin="svgSpinners3DotsMove5.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="0;3"
        />
        <animate
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove3.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="4;12"
        />
      </circle>
      <circle cx="20" cy="12" r="3" fill="currentColor">
        <animate
          id="svgSpinners3DotsMove6"
          fill="freeze"
          attributeName="r"
          begin="0;svgSpinners3DotsMove1.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="3;0"
        />
        <animate
          id="svgSpinners3DotsMove7"
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove6.end"
          dur="0.001s"
          values="20;4"
        />
        <animate
          fill="freeze"
          attributeName="r"
          begin="svgSpinners3DotsMove7.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="0;3"
        />
        <animate
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove5.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="4;12"
        />
        <animate
          fill="freeze"
          attributeName="cx"
          begin="svgSpinners3DotsMove3.end"
          calcMode="spline"
          dur="0.5s"
          keySplines=".36,.6,.31,1"
          values="12;20"
        />
      </circle>
    </svg>
  );
};

export default LoadingDot;

// File: src/core/sounds/SoundManager.jsx
import React, { useEffect, useRef } from "react";

const SoundManager = ({ soundType }) => {
  const moveSound = useRef(null);
  const captureSound = useRef(null);
  const checkSound = useRef(null);
  const castleSound = useRef(null);
  const promotionSound = useRef(null);

  useEffect(() => {
    switch (soundType) {
      case "move":
        moveSound.current.play();
        break;
      case "capture":
        captureSound.current.play();
        break;
      case "check":
        checkSound.current.play();
        break;
      case "castle":
        castleSound.current.play();
        break;
      case "promote":
        promotionSound.current.play();
        break;
      default:
        break;
    }
  }, [soundType]);

  return (
    <div>
      <audio ref={moveSound} src="/sounds/move.mp3" />
      <audio ref={captureSound} src="/sounds/capture.mp3" />
      <audio ref={checkSound} src="/sounds/check.mp3" />
      <audio ref={castleSound} src="/sounds/castle.mp3" />
      <audio ref={promotionSound} src="/sounds/promote.mp3" />
    </div>
  );
};

export default SoundManager;

// File: src/core/types/Bishop.ts
import Cell from "./Cell";
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class Bishop implements IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean = true;
  name: string = "Bishop";
  code: string = "B";
  value: number = 3;
  enPassant: Cell | null;

  constructor(color: Color, img: string) {
    this.color = color;
    this.img = img;
  }

  getNeighbors(board: BoardType, row: number, col: number): Cell[] {
    return [];
  }

  getPossiblesMove(from: Cell, board: BoardType): Cell[] {
    const directions = [
      [1, -1],
      [-1, 1],
      [1, 1],
      [-1, -1],
    ];
    const ans: Cell[] = [];

    for (const [dx, dy] of directions) {
      let next_row = from.row;
      let next_col = from.column;
      while (0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8) {
        next_row += dy;
        next_col += dx;

        if (!(0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8)) {
          break;
        }

        if (board[next_row][next_col].isEmpty) {
          ans.push(board[next_row][next_col]);
        } else {
          if (from.piece?.color !== board[next_row][next_col].piece?.color) {
            ans.push(board[next_row][next_col]);
          }
          break;
        }
      }
    }

    return ans;
  }
}

// File: src/core/types/Cell.ts
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class Cell {
  row: number;
  column: number;
  piece: IPiece | null = null;
  color: Color;
  board: BoardType;

  constructor(row: number, col: number, color: Color, board: BoardType) {
    this.row = row;
    this.column = col;
    this.color = color;
    this.board = board;
  }

  movesPossible(): Cell[] {
    if (this.piece == null) {
      return [];
    }
    return this.piece.getPossiblesMove(this, this.board);
  }

  movePieceTo(cell: Cell): boolean {
    if (this.piece == null) {
      return false;
    }

    this.piece.isFirstMove = false;
    cell.piece = this.piece;
    this.piece = null;
    return true;
  }

  get isEmpty() {
    return this.piece == null;
  }
}

// File: src/core/types/IPiece.ts
import Cell from "./Cell";
import { BoardType, Color } from "./Type";

export default interface IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean;
  name: string;
  code: string;
  value: number;
  enPassant: Cell | null;

  getPossiblesMove(from: Cell, board: BoardType): Cell[];
  getNeighbors(board: BoardType, row: number, col: number): Cell[];
}

// File: src/core/types/King.ts
import Cell from "./Cell";
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class King implements IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean = true;
  name: string = "King";
  code: string = "K";
  value: number = 0;
  enPassant: Cell | null;

  constructor(color: Color, img: string) {
    this.color = color;
    this.img = img;
  }
  getNeighbors(board: BoardType, row: number, col: number): Cell[] {
    return [];
  }

  getPossiblesMove(from: Cell, board: BoardType): Cell[] {
    const ans: Cell[] = [];
    const directions = [
      [0, 1],
      [0, -1],
      [1, 0],
      [1, 1],
      [1, -1],
      [-1, 0],
      [-1, 1],
      [-1, -1],
    ];

    for (const [dx, dy] of directions) {
      const next_row = from.row + dy;
      const next_col = from.column + dx;

      if (!(0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8)) {
        continue;
      }

      if (board[next_row][next_col].isEmpty) {
        ans.push(board[next_row][next_col]);
      } else {
        if (from.piece?.color !== board[next_row][next_col].piece?.color) {
          ans.push(board[next_row][next_col]);
        }
      }
    }

    return ans.concat(this.roque(from, board));
  }

  roque(from: Cell, board: BoardType): Cell[] {
    if (!this.isFirstMove) return [];

    const possibleMoves: Cell[] = [];
    const directions = [-2, 2]; // two move possible big castle and small castle

    for (const dx of directions) {
      const direction = Math.abs(dx) / dx; // Direction of movement

      let next_col = from.column + direction;
      while (0 < next_col && next_col < 7) {
        //Check if not piece between king and rook
        if (!board[from.row][next_col].isEmpty) {
          break;
        }

        next_col += direction;
      }

      const cellRook = board[from.row][next_col]; // it might not be the rook cell

      if (
        [0, 7].includes(next_col) && //check if it is a rook cell
        !cellRook.isEmpty &&
        cellRook.piece?.isFirstMove
      ) {
        possibleMoves.push(board[from.row][from.column + dx]);
      }
    }

    return possibleMoves;
  }
}

// File: src/core/types/Knight.ts
import Cell from "./Cell";
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class Knight implements IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean = true;
  name: string = "Knight";
  code: string = "N";
  value: number = 3;
  enPassant: Cell | null;

  constructor(color: Color, img: string) {
    this.color = color;
    this.img = img;
  }
  getNeighbors(board: BoardType, row: number, col: number): Cell[] {
    return [];
  }

  getPossiblesMove(from: Cell, board: BoardType): Cell[] {
    const ans: Cell[] = [];
    const directions = [
      [2, 1],
      [2, -1],
      [1, 2],
      [1, -2],
      [-2, 1],
      [-2, -1],
      [-1, 2],
      [-1, -2],
    ];

    for (const [dx, dy] of directions) {
      const next_row = from.row + dy;
      const next_col = from.column + dx;

      if (this.valid(next_row, next_col, from, board)) {
        ans.push(board[next_row][next_col]);
      }
    }

    return ans;
  }

  valid = (row: number, col: number, from: Cell, board: BoardType) => {
    if (!(0 <= row && row < 8 && 0 <= col && col < 8)) {
      return false;
    }

    if (from.piece?.color === board[row][col].piece?.color) {
      return false;
    }

    return true;
  };
}

// File: src/core/types/Pawn.ts
import Cell from "./Cell";
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class Pawn implements IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean = true;
  name: string = "Pawn";
  code: string = "P";
  value: number = 1;
  enPassant: Cell | null = null;

  constructor(color: Color, img: string) {
    this.color = color;
    this.img = img;
  }

  getPossiblesMove(from: Cell, board: BoardType): Cell[] {
    const possibleMove: Cell[] = [];

    const directions =
      this.color === "white"
        ? [
            [0, -1],
            [1, -1],
            [-1, -1],
          ]
        : [
            [0, 1],
            [-1, 1],
            [1, 1],
          ];

    if (this.color === "white" && from.row === 6) {
      directions.push([0, -2]);
    }
    if (this.color === "black" && from.row === 1) {
      directions.push([0, 2]);
    }

    for (const [dx, dy] of directions) {
      const next_row = from.row + dy;
      const next_col = from.column + dx;

      if (this.validPawn(next_row, next_col, from, board)) {
        possibleMove.push(board[next_row][next_col]);
      }
    }

    return possibleMove;
  }
  validPawn = (
    row: number,
    col: number,
    from: Cell,
    board: BoardType
  ): boolean => {
    if (!(0 <= row && row < 8 && 0 <= col && col < 8)) {
      //out of bound
      return false;
    }

    if (board[row][col].piece) {
      // there is a piece on the targe cell (take in diagonale)
      if (from.piece?.color === board[row][col].piece?.color) {
        return false;
      }

      if (from.column === col) {
        return false;
      }
    } else {
      if (col !== from.column) {
        return false;
      } else {
        if (from.row === 6 && row === 4 && !board[5][col].isEmpty) {
          return false;
        }

        if (from.row === 1 && row === 3 && !board[2][col].isEmpty) {
          return false;
        }
      }
      return true;
    }

    return true;
  };

  getNeighbors(board: BoardType, row: number, col: number): Cell[] {
    const neighbors: Cell[] = [];

    if (
      col + 1 < 8 &&
      !board[row][col + 1].isEmpty &&
      board[row][col + 1].piece?.color !== this.code &&
      board[row][col + 1].piece?.code === "P"
    ) {
      neighbors.push(board[row][col + 1]);
    }

    if (
      col - 1 >= 0 &&
      !board[row][col - 1].isEmpty &&
      board[row][col - 1].piece?.color !== this.color &&
      board[row][col - 1].piece?.code === "P"
    ) {
      neighbors.push(board[row][col - 1]);
    }

    return neighbors;
  }
}

// File: src/core/types/Player.ts
import { Color } from "./Type";

export default class Player {
  name: string;
  color: Color;
}

// File: src/core/types/Queen.ts
import Cell from "./Cell";
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class Queen implements IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean = true;
  name: string = "Queen";
  code: string = "Q";
  value: number = 9;
  enPassant: Cell | null;

  constructor(color: Color, img: string) {
    this.color = color;
    this.img = img;
  }
  getNeighbors(board: BoardType, row: number, col: number): Cell[] {
    return [];
  }

  getPossiblesMove(from: Cell, board: BoardType): Cell[] {
    const directions = [
      [0, -1],
      [0, 1],
      [1, 0],
      [-1, 0],
      [1, -1],
      [-1, 1],
      [1, 1],
      [-1, -1],
    ];

    const ans: Cell[] = [];

    for (const [dx, dy] of directions) {
      let next_row = from.row;
      let next_col = from.column;
      while (0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8) {
        next_row += dy;
        next_col += dx;

        if (!(0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8)) {
          break;
        }

        if (board[next_row][next_col].isEmpty) {
          ans.push(board[next_row][next_col]);
        } else {
          if (from.piece?.color !== board[next_row][next_col].piece?.color) {
            ans.push(board[next_row][next_col]);
          }
          break;
        }
      }
    }

    return ans;
  }
}

// File: src/core/types/Rook.ts
import Cell from "./Cell";
import IPiece from "./IPiece";
import { BoardType, Color } from "./Type";

export default class Rook implements IPiece {
  color: Color;
  img: string;
  isFirstMove: boolean = true;
  name: string = "Rook";
  code: string = "R";
  value: number = 5;
  enPassant: Cell | null;

  constructor(color: Color, img: string) {
    this.color = color;
    this.img = img;
  }
  getNeighbors(board: BoardType, row: number, col: number): Cell[] {
    return [];
  }

  getPossiblesMove(from: Cell, board: BoardType): Cell[] {
    const directions = [
      [0, -1],
      [0, 1],
      [1, 0],
      [-1, 0],
    ];

    const ans: Cell[] = [];

    for (const [dx, dy] of directions) {
      let next_row = from.row;
      let next_col = from.column;
      while (0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8) {
        next_row += dy;
        next_col += dx;

        if (!(0 <= next_row && next_row < 8 && 0 <= next_col && next_col < 8)) {
          break;
        }

        if (board[next_row][next_col].isEmpty) {
          ans.push(board[next_row][next_col]);
        } else {
          if (from.piece?.color !== board[next_row][next_col].piece?.color) {
            ans.push(board[next_row][next_col]);
          }
          break;
        }
      }
    }

    return ans;
  }
}

// File: src/core/types/Type.ts
import Game from "../config/Game";
import Cell from "./Cell";

export type Color = "white" | "black";
export type BoardType = Cell[][];

export interface BoardProps {
  game: Game;
}

export type Move = {
  from: number[];
  to: number[];
  promotion: string | null;
  timer: number;
  color: Color;
};

export type ReMatch = {
  request: boolean;
  requester: Color;
  response: boolean;
};

export enum MoveType {
  MOVE = "move",
  CASTLE = "castle",
  CAPTURE = "capture",
  PROMOTE = "promote",
  CHECK = "check",
  WRONG = "wrong",
}

export class NodeMove {
  state: Cell[] | null = null;
  prevState: NodeMove;
  nextState: NodeMove;
  type: MoveType = MoveType.MOVE;
  currentMove: Cell[] | null = null;
}

// File: src/index.css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow: hidden;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

// File: src/index.js
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

